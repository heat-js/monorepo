{"script":"-- valueKey timestampKey | limit intervalMS nowMS [amount]\nlocal valueKey     = KEYS[1] -- \"limit:1:V\"\nlocal timestampKey = KEYS[2] -- \"limit:1:T\"\nlocal limit        = tonumber(ARGV[1])\nlocal intervalMS   = tonumber(ARGV[2])\nlocal amount       = math.max(tonumber(ARGV[3]), 0)\n\nlocal lastUpdateMS\nlocal prevTokens\n\n-- Use effects replication, not script replication;; this allows us to call 'TIME' which is non-deterministic\nredis.replicate_commands()\n\nlocal time = redis.call('TIME')\nlocal nowMS = math.floor((time[1] * 1000) + (time[2] / 1000))\nlocal initialTokens = redis.call('GET',valueKey)\nlocal initialUpdateMS = false\n\n\nif initialTokens == false then\n   -- If we found no record, we temporarily rewind the clock to refill\n   -- via addTokens below\n   prevTokens = 0\n   lastUpdateMS = nowMS - intervalMS\nelse\n   prevTokens = initialTokens\n   initialUpdateMS = redis.call('GET',timestampKey)\n\n   if(initialUpdateMS == false) then -- this is a corruption\n      -- we make up a time that would fill this limit via addTokens below\n      lastUpdateMS = nowMS - ((prevTokens / limit) * intervalMS)\n   else\n      lastUpdateMS = initialUpdateMS\n   end\nend\n\n-- tokens that should have been added by now\n-- note math.max in case this ends up negative (clock skew?)\n-- now that we call 'TIME' this is less likely to happen\nlocal addTokens = math.max(((nowMS - lastUpdateMS) / intervalMS) * limit, 0)\n\n-- calculated token balance coming into this transaction\nlocal grossTokens = math.min(prevTokens + addTokens, limit)\n\n-- token balance after trying this transaction\nlocal netTokens = grossTokens - amount\n\nlocal retryDelta = 0\n\nif netTokens < 0 then\n\tretryDelta = math.ceil((math.abs(netTokens) / limit) * intervalMS)\nend\n\nreturn { grossTokens, retryDelta }\n","sha1":"10d8f12e9cb324a82767d08672c48247bf2bb373"}